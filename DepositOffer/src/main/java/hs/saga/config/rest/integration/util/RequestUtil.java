// THIS FILE IS AUTOGENERATED. MODIFICATIONS WILL BE LOST!

package hs.saga.config.rest.integration.util;

import hs.saga.config.rest.integration.error.ApiBindingNotFound;
import hs.saga.config.rest.integration.model.ApiBinding;
import hs.saga.config.rest.integration.service.AccessTokenService;
import hs.saga.config.rest.integration.service.ApiBindingService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.*;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.springframework.web.util.UriComponentsBuilder;

import javax.servlet.http.HttpServletRequest;
import java.net.URI;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Utility service to create external request to integration APIs. It
 * uses @link{ApiBindingService} to get API Binding using binding name.
 *
 * @Generated
 */
@Service
public class RequestUtil {

  private static final Logger log = LoggerFactory.getLogger(RequestUtil.class);

  private final RestTemplate restTemplate;
  private final ApiBindingService bindingService;
  private final AccessTokenService accessTokenService;

  public RequestUtil(ApiBindingService bindingService, RestTemplate restTemplate, AccessTokenService accessTokenService) {
    this.restTemplate = restTemplate;
    this.bindingService = bindingService;
    this.accessTokenService = accessTokenService;
  }

  /**
   * Generic method to Create a request and return single return object.
   *
   * @param bindingName Api binding name
   * @param path api path
   * @param httpMethod http method
   * @param returnType class of return object
   * @param body request body
   * @param pathParams path parameters map
   * @param queryParams query parameters map
   * @param headerParams http headers
   * @return ResponseEntity
   */
  public <T> ResponseEntity<T> requestForOne(String bindingName, String path, String httpMethod, Class<T> returnType,
      Object body, Map<String, Object> pathParams, Map<String, Object> queryParams, HttpHeaders headerParams) {

    // Prepare request object
    RequestObject request = this.prepareRequest(bindingName, path, body, pathParams, queryParams, headerParams);

    // Resolve HTTP method
    HttpMethod method = HttpMethod.resolve(httpMethod);

    log.debug("Creating {} request for {}", httpMethod, request.uri);

    // Call RestTemplate exchange method
    ResponseEntity<T> response = restTemplate.exchange(request.uri, method, request.requestEntity, returnType);

    return response;
  }

  /**
   * Generic method to Create a request and return array of objects.
   *
   * @param bindingName Api binding name
   * @param path api path
   * @param httpMethod http method
   * @param returnType class of return object
   * @param body request body
   * @param pathParams path parameters map
   * @param queryParams query parameters map
   * @param headerParams http headers
   * @return ResponseEntity
   */
  public <T> ResponseEntity<T[]> requestForMany(String bindingName, String path, String httpMethod,
      Class<T[]> returnType, Object body, Map<String, Object> pathParams, Map<String, Object> queryParams,
      HttpHeaders headerParams) {

    // Prepare request object
    RequestObject request = prepareRequest(bindingName, path, body, pathParams, queryParams, headerParams);

    // Resolve HTTP method
    HttpMethod method = HttpMethod.resolve(httpMethod);

    log.debug("Creating {} request for {}", httpMethod, request.uri);

    // Call RestTemplate exchange method
    ResponseEntity<T[]> response = restTemplate.exchange(request.uri, method, request.requestEntity, returnType);

    return response;
  }

  /**
   * Helper method to prepare @link{RequestObject}
   *
   * @param bindingName Api binding name
   * @param path api path
   * @param body request body
   * @param pathParams
   * @param queryParams
   * @param headerParams http headers
   * @return RequestObject containing request entity @link{HttpEntity} and Url
   */
    private RequestObject prepareRequest(String bindingName,
                                         String path, Object body,
                                         Map<String, Object> pathParams,
                                         Map<String, Object> queryParams,
                                         HttpHeaders headerParams) {

    // retrieve API binding using binding name
    Optional<ApiBinding> apiBinding = bindingService.getApiBinding(bindingName);
    if (apiBinding.isPresent() == false) {
      throw new ApiBindingNotFound("Unable to load api binding for " + bindingName);
    }

    // Add ACCEPT & CONTENT_TYPE headers if not present
    headerParams = (headerParams == null) ? new HttpHeaders() : headerParams;
    headerParams.putIfAbsent(HttpHeaders.ACCEPT, Arrays.asList(MediaType.APPLICATION_JSON_VALUE));
    headerParams.putIfAbsent(HttpHeaders.CONTENT_TYPE, Arrays.asList(MediaType.APPLICATION_JSON_VALUE));

    // Filter out null header parameter values
    headerParams.values().removeIf( x-> this.isEmptyHeaderValue(x));

    // Filter out null query parameter values
    queryParams.values().removeIf(Objects::isNull);


    // Build URI
    String url = apiBinding.get().getUrl() + path;
    UriComponentsBuilder uriComponents = UriComponentsBuilder.fromUriString(url);
    // Handle Query Parameters
    if(queryParams != null) {
      queryParams.forEach((key, value) -> {
        if(value instanceof Collection<?>) {
          uriComponents.queryParam(key, (Collection<?>) value);
        } else {
          uriComponents.queryParam(key, value);
        }
      });
    }

    // Handle Path Parameters
    URI uri;
    if(pathParams != null) {
      uri = uriComponents.buildAndExpand(pathParams).toUri();
    } else {
      uri = uriComponents.build().toUri();
    }

    // Propagate JWT token
    if (apiBinding.get().isK5PropagateSecurityToken()) {
      headerParams = propagateJwtToken(headerParams);
    }

    // Prepare request entity with body and headers
    HttpEntity<?> requestEntity = new HttpEntity<>(body, headerParams);

    return new RequestObject(requestEntity, uri);
  }

  /**
   * Helper method to get current @link{HttpServletRequest}
   *
   * @return HttpServletRequest current http servlet request if it exists.
   */
  public static Optional<HttpServletRequest> getCurrentHttpRequest() {
    return Optional.ofNullable(RequestContextHolder.getRequestAttributes())
        .filter(requestAttributes -> ServletRequestAttributes.class.isAssignableFrom(requestAttributes.getClass()))
        .map(requestAttributes -> ((ServletRequestAttributes) requestAttributes))
        .map(ServletRequestAttributes::getRequest);
  }

  /**
   * Helper method to add Authorization header
   *
   * @param headerParams
   * @return http headers with Authentication header added
   */
  public HttpHeaders propagateJwtToken(HttpHeaders headerParams) {

    // Propagate JWT header
    Optional<HttpServletRequest> currentRequest = getCurrentHttpRequest();
    if (currentRequest.isPresent() && currentRequest.get() != null) {
      headerParams = (headerParams == null) ? new HttpHeaders() : headerParams;
      String auth = currentRequest.get().getHeader("Authorization");
      headerParams.add("Authorization", auth);
    } else {
      log.info("No Current HTTP Request Present, will attempt to obtain JWT token");

      // Initiate loginAsTechnicalUser flow
      accessTokenService.loginAsTechnicalUser();

      // Get JwtAuthenticationToken
      JwtAuthenticationToken jwtAuth = (JwtAuthenticationToken) SecurityContextHolder.getContext().getAuthentication();

      // Set Authorization header with jwt token value
      headerParams.add("Authorization", "Bearer " + jwtAuth.getToken().getTokenValue());
    }

    return headerParams;
  }

  /**
   * Utility function to filter out null header value elements
   * @param headerValue
   * @return boolean to check whether header value is empty or not
   */
  private boolean isEmptyHeaderValue(List<String> headerValue) {

    if(headerValue == null || headerValue.isEmpty()) {
      return true;
    }

    // filter out potential null elements within header list of values
    return headerValue.stream().filter(Objects::nonNull).collect(Collectors.toList()).isEmpty();
  }

  /**
   * Anonymous class to group request entity @link{HttpEntity} and Url
   *
   */
  static class RequestObject {

    URI uri;
    HttpEntity<?> requestEntity;

    public RequestObject(HttpEntity<?> requestEntity, URI uri) {
      this.requestEntity = requestEntity;
      this.uri = uri;
    }
  }
}
